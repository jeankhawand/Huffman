<!DOCTYPE html>
    <html>
    <head>
        <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
        <title>Huffman Code</title>
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        
        
    </head>
    <body>
        <h1 id="Huffman-Code">Huffman Code</h1>
<p>Huffman code is a type of optimal prefix code that is commonly used for lossless data compression. The
algorithm has been developed by <strong>David A. Huffman</strong>. The technique works by creating a binary tree of
nodes.</p>
<h2 id="Concept">Concept</h2>
<p>The main idea is to transform plain input into variable-length code. More frequent symbols are generally
represented using fewer bits than less frequent symbols. The easiest way to understand how to create
Huffman tree is to analyze following steps:</p>
<ol>
<li>Scan text for symbols (e.g. 1-byte characters) and calculate their frequency of occurrence.</li>
<li>Start a loop.</li>
<li>Find two smallest probability nodes and combine them into single node.</li>
<li>Remove those two nodes from list and insert combined one.</li>
<li>Repeat the loop until the list has only one single node.</li>
<li>This last single node represents a Huffman tree.</li>
</ol>
<h2 id="Use-Case">Use Case</h2>
<p>Let us consider the example where the input file contains the following sentence:</p>
<blockquote>
<p><strong>a simple string to be encoded using a minimal number of bits</strong></p>
</blockquote>
<p>Step 1 starts by scanning the input file and returning a simply linked list. This list contains the available
characters along with their frequency of occurrence. Once it is sorted according to the frequencies of
occurrence and the lexicographic order, the simply linked list holds the following information:</p>
<table>
<thead>
<tr>
<th>1</th>
<th>1</th>
<th>1</th>
<th>2</th>
<th>2</th>
<th>2</th>
<th>2</th>
<th>2</th>
<th>3</th>
<th>3</th>
<th>3</th>
<th>3</th>
<th>4</th>
<th>4</th>
<th>5</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td>c</td>
<td>f</td>
<td>p</td>
<td>d</td>
<td>g</td>
<td>l</td>
<td>r</td>
<td>u</td>
<td>a</td>
<td>b</td>
<td>o</td>
<td>t</td>
<td>m</td>
<td>s</td>
<td>e</td>
<td>n</td>
<td>i</td>
</tr>
</tbody>
</table>
<p>We select the two nodes with the least frequencies and we replace them with one single node
combining the previous two nodes. In our example, we select nodes ‘c’ and ‘f’, and we replace them
with the node ‘cf’ where the frequency is set to be equal to the sum of the two previous frequencies.
The new node is inserted back into the simply linked list while keeping it sorted according to the
frequencies of occurrence and the lexicographic order. The resulting list is as follows:</p>
<table>
<thead>
<tr>
<th>1</th>
<th>2</th>
<th>2</th>
<th>2</th>
<th>2</th>
<th>2</th>
<th>2</th>
<th>3</th>
<th>3</th>
<th>3</th>
<th>3</th>
<th>4</th>
<th>4</th>
<th>5</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td>p</td>
<td>¤</td>
<td>d</td>
<td>g</td>
<td>l</td>
<td>r</td>
<td>u</td>
<td>a</td>
<td>b</td>
<td>o</td>
<td>t</td>
<td>m</td>
<td>s</td>
<td>e</td>
<td>n</td>
<td>i</td>
</tr>
<tr>
<td></td>
<td>cf</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>These steps are repeated again and again until we end up with one single node. Now, we combine
nodes ‘p’ and ‘cf’ into one single node and add up there frequencies. The resulting list is as follows:</p>
<table>
<thead>
<tr>
<th>2</th>
<th>2</th>
<th>2</th>
<th>2</th>
<th>2</th>
<th>3</th>
<th>3</th>
<th>3</th>
<th>3</th>
<th>3</th>
<th>4</th>
<th>4</th>
<th>5</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td>d</td>
<td>g</td>
<td>l</td>
<td>r</td>
<td>u</td>
<td>a</td>
<td>b</td>
<td>o</td>
<td>¤</td>
<td>t</td>
<td>m</td>
<td>s</td>
<td>e</td>
<td>n</td>
<td>i</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>pcf</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>The next step is to combine nodes ‘d’ and ‘g’ into one single node and add up their frequencies. The
resulting list is as follows:</p>
<table>
<thead>
<tr>
<th>2</th>
<th>2</th>
<th>2</th>
<th>3</th>
<th>3</th>
<th>3</th>
<th>3</th>
<th>3</th>
<th>4</th>
<th>4</th>
<th>4</th>
<th>5</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td>l</td>
<td>r</td>
<td>u</td>
<td>a</td>
<td>b</td>
<td>o</td>
<td>¤</td>
<td>t</td>
<td>¤</td>
<td>m</td>
<td>s</td>
<td>e</td>
<td>n</td>
<td>i</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>pcf</td>
<td></td>
<td>dg</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>At the end of this modification process, the result can be represented as a binary tree as follows:</p>
<p><img src="file:////Users/jeankhawand/Downloads/Huffman/assets/1.png" alt="Image1"></p>
<p>In the previous figure, the single root node is represented in red, the left child is represented in blue and
the right child is represented in green. In order to get the Huffman code of any character, it is sufficient
to go through the binary tree and assign the integer number 0 to each left child and the integer number
1 to each right child. Thus, the Huffman code associated with the character ‘a’ would be ‘0101’ as
depicted in the figure below:</p>
<p><img src="file:////Users/jeankhawand/Downloads/Huffman/assets/2.png" alt="Image2"></p>
<p>The Huffman codes of all the characters present in the original text is the following:</p>
<ul>
<li>a : 0 1 0 1</li>
<li>b : 0 1 1 0</li>
<li>c : 1 0 1 0 1 0</li>
<li>d : 1 1 0 0 0</li>
<li>e : 0 0 0</li>
<li>f : 1 0 1 0 1 1</li>
<li>g : 1 1 0 0 1</li>
<li>i : 1 0 0</li>
<li>l : 1 1 0 1 0</li>
<li>m : 1 1 1 0</li>
<li>n : 0 0 1</li>
<li>o : 0 1 1 1</li>
<li>p : 1 0 1 0 0</li>
<li>r : 1 1 0 1 1</li>
<li>s : 1 1 1 1</li>
<li>t : 1 0 1 1</li>
<li>u : 0 1 0 0</li>
</ul>
<h2 id="Assignment">Assignment</h2>
<p>Your task is to write down the following 5 functions defined in the file <strong>StdFunctions.cpp</strong>.</p>
<pre><code><div>Node* ReadFile(const char* fileName);

Node* IncFrequency(Node* Head, char c);

void Sort(Node* Head);

Node* InsertSorted(Node* Head, Node* elt);

Node* SearchTree(Node* Tree, std::string C);

</div></code></pre>
<p>Please check the file <strong>StdFunctions.cpp</strong> for the detailed description of these functions.
You are not allowed to modify the other files unless you want to add new functionalities to the code.
Please submit your code to your instructors by mail the day before your project defense.</p>

    </body>
    </html>